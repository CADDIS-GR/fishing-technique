<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Naked Fishing Strategy</title>
    <style>
        body {
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #222;
            font-family: 'Noto Sans KR', sans-serif;
            color: white;
        }
        h2 {
            margin: 10px 0;
            color: #ffcc00;
        }
        canvas {
            background: linear-gradient(to bottom, #87CEEB 0%, #87CEEB 30%, #2F4F4F 30%, #1a2e2e 100%);
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            border-radius: 8px;
            max-width: 100%;
        }
        .controls {
            margin-top: 10px;
            display: flex;
            gap: 10px;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            background-color: #ff9900;
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-weight: bold;
        }
        button:hover {
            background-color: #e68a00;
        }
        button.active {
            background-color: #00cc66;
        }
        .legend {
            margin-top: 10px;
            font-size: 14px;
            color: #ddd;
            text-align: left;
            width: 800px;
            display: flex;
            justify-content: space-between;
        }
    </style>
</head>
<body>

    <h2>ğŸ£ ë‚šì‹œëŒ€ì¥ì˜ Naked Fishing Strategy</h2>
    <canvas id="fishingCanvas" width="800" height="500"></canvas>
    
    <div class="controls">
        <button onclick="resetAnimation()">â–¶ ìºìŠ¤íŒ… & ì•¡ì…˜ ì‹œì‘ (Replay)</button>
        <button id="indicatorBtn" onclick="toggleIndicator()">ğŸ¯ ì¸ë””ì¼€ì´í„° ON/OFF</button>
    </div>

    <div class="legend">
        <div>
            <strong>[ì±„ë¹„ êµ¬ì„±]</strong><br>
            ğŸ£ <strong>ROD:</strong> Sage DS2 690-2 (#6)<br>
            ğŸ§µ <strong>LINE:</strong> SA Emerger Tip (WF-6-F/I)<br>
            ğŸ”— <strong>LEADER:</strong> 15ft Fluorocarbon (4X+4.5X)<br>
            ğŸª° <strong>FLY:</strong> 2.5mm Tungsten (Leech/Pupa)
        </div>
        <div>
            <strong>[í•„ë“œ & ì•¡ì…˜]</strong><br>
            ğŸŒŠ <strong>MAX DEPTH:</strong> 4.2m<br>
            â±ï¸ <strong>COUNT:</strong> 20ì´ˆ (ë°”ë‹¥ì¸µ ë„ë‹¬)<br>
            âœ‹ <strong>ACTION:</strong> 8ì í•œ ê¼¬ì§‘ (ìˆ˜í‰ ìœ ì˜)<br>
            ğŸ¯ <strong>TARGET:</strong> 4mê¶Œ ë°”ë‹¥ì¸µ
        </div>
    </div>

    <script>
        const canvas = document.getElementById('fishingCanvas');
        const ctx = canvas.getContext('2d');

        // ìƒíƒœ ë³€ìˆ˜
        let animationState = 'cast';
        let timer = 0;
        let castProgress = 0;
        let flyX = 100;
        let flyY = 150;
        let indicatorX = 100;
        let indicatorY = 150;
        let showIndicator = false;
        let indicatorBobAmount = 0;
        let isComplete = false; // ì™„ë£Œ í”Œë˜ê·¸ ì¶”ê°€
        
        // ìƒìˆ˜
        const WATER_LEVEL = 150;
        const BOTTOM_LEVEL = 450;
        const CAST_DISTANCE = 600;
        const SINK_TIME_LIMIT = 20;
        const INDICATOR_DISTANCE = 200;
        const RETRIEVE_END_X = 300; // ë¦¬íŠ¸ë¦¬ë¸Œ ì¢…ë£Œ ì§€ì  (ë‚šì‹œê¾¼ ì•)

        function toggleIndicator() {
            showIndicator = !showIndicator;
            const btn = document.getElementById('indicatorBtn');
            if (showIndicator) {
                btn.classList.add('active');
                btn.textContent = 'ğŸ¯ ì¸ë””ì¼€ì´í„° ON';
            } else {
                btn.classList.remove('active');
                btn.textContent = 'ğŸ¯ ì¸ë””ì¼€ì´í„° OFF';
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawBackground();
            drawFisherman();

            // ì™„ë£Œ ìƒíƒœê°€ ì•„ë‹ ë•Œë§Œ ì—…ë°ì´íŠ¸
            if (!isComplete) {
                if (animationState === 'cast') {
                    updateCast();
                } else if (animationState === 'sink') {
                    updateSink();
                } else if (animationState === 'retrieve') {
                    updateRetrieve();
                }
            }

            drawGear();
            requestAnimationFrame(draw);
        }

        function drawBackground() {
            ctx.fillStyle = "rgba(255, 255, 255, 0.2)";
            ctx.font = "12px Arial";
            ctx.fillText("ìˆ˜ë©´ (0m)", 720, WATER_LEVEL - 5);
            
            ctx.beginPath();
            ctx.strokeStyle = "rgba(255, 255, 255, 0.1)";
            ctx.moveTo(0, WATER_LEVEL + 75);
            ctx.lineTo(800, WATER_LEVEL + 75);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(0, WATER_LEVEL + 150);
            ctx.lineTo(800, WATER_LEVEL + 150);
            ctx.stroke();
            ctx.fillText("2.0m", 750, WATER_LEVEL + 150 - 5);

            ctx.beginPath();
            ctx.moveTo(0, WATER_LEVEL + 300);
            ctx.lineTo(800, WATER_LEVEL + 300);
            ctx.stroke();
            ctx.fillText("4.0m", 750, WATER_LEVEL + 300 - 5);

            ctx.fillStyle = "#3e2723";
            ctx.fillRect(0, BOTTOM_LEVEL, 800, 50);
            ctx.fillStyle = "#a1887f";
            ctx.fillText("ë°”ë‹¥ (4.2m)", 720, BOTTOM_LEVEL - 5);

            drawFish(600, 400);
            drawFish(450, 420);
        }

        function drawFish(x, y) {
            ctx.fillStyle = "#CD853F";
            ctx.beginPath();
            ctx.ellipse(x, y, 15, 6, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(x + 15, y);
            ctx.lineTo(x + 22, y - 5);
            ctx.lineTo(x + 22, y + 5);
            ctx.fill();
        }

        function drawFisherman() {
            ctx.fillStyle = "#333";
            ctx.fillRect(50, 80, 20, 70);
            ctx.beginPath();
            ctx.arc(60, 70, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(60, 100);
            ctx.lineTo(120, 50);
            ctx.stroke();
        }

        function updateCast() {
            castProgress += 15;
            flyX = 120 + castProgress;
            flyY = WATER_LEVEL;
            
            if (showIndicator) {
                indicatorX = flyX - INDICATOR_DISTANCE;
                indicatorY = WATER_LEVEL;
            }
            
            if (flyX >= CAST_DISTANCE) {
                flyX = CAST_DISTANCE;
                if (showIndicator) {
                    indicatorX = flyX - INDICATOR_DISTANCE;
                }
                animationState = 'sink';
                timer = 0;
            }
        }

        function updateSink() {
            if (timer < SINK_TIME_LIMIT) {
                timer += 0.1;
                let maxSinkDepth = BOTTOM_LEVEL - 20;
                let progress = timer / SINK_TIME_LIMIT;
                flyY = WATER_LEVEL + (maxSinkDepth - WATER_LEVEL) * progress;
                
                if (showIndicator) {
                    indicatorY = WATER_LEVEL;
                    let tension = (flyY - WATER_LEVEL) / (maxSinkDepth - WATER_LEVEL);
                    indicatorBobAmount = tension * 15;
                    indicatorY = WATER_LEVEL + indicatorBobAmount;
                }
            } else {
                animationState = 'retrieve';
            }
        }

        function updateRetrieve() {
            // ë‹¤ìŒ í”„ë ˆì„ì˜ ìœ„ì¹˜ë¥¼ ë¯¸ë¦¬ ê³„ì‚°
            let nextFlyX = flyX - 1.0;
            
            // ëª©í‘œ ì§€ì ì— ë„ë‹¬í•˜ê±°ë‚˜ ì§€ë‚˜ì³¤ëŠ”ì§€ ì²´í¬
            if (nextFlyX <= RETRIEVE_END_X) {
                // ì™„ë£Œ ìƒíƒœë¡œ ì„¤ì •
                isComplete = true;
                animationState = 'complete';
                flyX = RETRIEVE_END_X;
                flyY = WATER_LEVEL + 30;
                if (showIndicator) {
                    indicatorX = RETRIEVE_END_X - 50;
                    indicatorY = WATER_LEVEL;
                }
                return;
            }
            
            // ì•„ì§ ë„ë‹¬í•˜ì§€ ì•Šì•˜ìœ¼ë©´ ê³„ì† ì´ë™ (ì ˆëŒ€ ëª©í‘œ ì§€ì ë³´ë‹¤ ì‘ì•„ì§€ì§€ ì•Šë„ë¡)
            flyX = Math.max(nextFlyX, RETRIEVE_END_X);
            flyY = (BOTTOM_LEVEL - 20) + Math.sin(flyX * 0.1) * 2;
            
            if (showIndicator) {
                indicatorX = Math.max(indicatorX - 1.0, RETRIEVE_END_X - 50);
                let retrieveTension = Math.abs(Math.sin(flyX * 0.1)) * 8;
                indicatorY = WATER_LEVEL + retrieveTension + Math.sin(flyX * 0.2) * 3;
            }
            
            // ì •í™•íˆ ë„ë‹¬í–ˆìœ¼ë©´ ì™„ë£Œ ì²˜ë¦¬
            if (flyX === RETRIEVE_END_X) {
                isComplete = true;
                animationState = 'complete';
                flyY = WATER_LEVEL + 30;
                if (showIndicator) {
                    indicatorY = WATER_LEVEL;
                }
            }
        }

        function drawGear() {
            let lineWaterEntry = 250;
            
            // ë©”ì¸ ë¼ì¸
            ctx.beginPath();
            ctx.strokeStyle = "#FF8C00";
            ctx.lineWidth = 2;
            ctx.moveTo(120, 50);

            if (animationState === 'cast') {
                ctx.lineTo(flyX, 50);
            } else {
                let connectionPoint = showIndicator ? indicatorX : lineWaterEntry;
                ctx.quadraticCurveTo(150, 120, connectionPoint, WATER_LEVEL);
                ctx.stroke();

                if (showIndicator) {
                    // ì¸ë””ì¼€ì´í„°ì—ì„œ í”Œë¼ì´ê¹Œì§€ ë¦¬ë” ë¼ì¸
                    ctx.beginPath();
                    ctx.strokeStyle = "rgba(200, 255, 255, 0.8)";
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([3, 3]);
                    ctx.moveTo(indicatorX, indicatorY);
                    ctx.lineTo(flyX, flyY);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // ì¸ë””ì¼€ì´í„° ê·¸ë¦¬ê¸°
                    drawIndicator(indicatorX, indicatorY);
                } else {
                    // ê¸°ì¡´ ë¼ì¸ (ì¸ë””ì¼€ì´í„° ì—†ì„ ë•Œ)
                    ctx.beginPath();
                    ctx.strokeStyle = "#808000";
                    let tipStart = flyX - (flyX - lineWaterEntry) * 0.2;
                    ctx.moveTo(lineWaterEntry, WATER_LEVEL);
                    ctx.lineTo(tipStart, WATER_LEVEL);
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.strokeStyle = "rgba(200, 255, 255, 0.6)";
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 2]);
                    ctx.moveTo(tipStart, WATER_LEVEL);
                    ctx.lineTo(flyX, flyY);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }

            // í”Œë¼ì´
            ctx.fillStyle = "#FF0000";
            ctx.beginPath();
            ctx.arc(flyX, flyY, 4, 0, Math.PI * 2);
            ctx.fill();

            // ì •ë³´ í…ìŠ¤íŠ¸
            ctx.fillStyle = "white";
            ctx.font = "bold 16px Arial";
            
            // ë””ë²„ê·¸ ì •ë³´ (flyX ìœ„ì¹˜ í‘œì‹œ)
            ctx.fillStyle = "#FFFFFF";
            ctx.font = "12px Arial";
            ctx.fillText(`FlyX: ${Math.floor(flyX)} / End: ${RETRIEVE_END_X}`, 20, 30);
            
            if (animationState === 'sink') {
                ctx.fillStyle = "#FFFF00";
                ctx.fillText(`â±ï¸ ì¹´ìš´íŠ¸ë‹¤ìš´: ${Math.floor(timer)} / 20ì´ˆ`, 350, 100);
                ctx.fillText("â–¼ ì¹¨ê°• ì¤‘ (Free Fall)", flyX + 10, flyY);
                
                if (showIndicator) {
                    ctx.fillStyle = "#FF6600";
                    ctx.font = "12px Arial";
                    ctx.fillText("ğŸ¯ ì¸ë””ì¼€ì´í„° ë°˜ì‘ ì¤‘", indicatorX - 60, indicatorY - 20);
                }
            } else if (animationState === 'retrieve') {
                ctx.fillStyle = "#00FFFF";
                ctx.fillText("âœ‹ 8ì ë¦¬íŠ¸ë¦¬ë¸Œ ì¤‘ (ìˆ˜í‰ ìœ ì˜)", 350, 100);
                ctx.fillText("â—€ ì€ë°€í•œ ìˆ˜í‰ ì´ë™", flyX + 10, flyY);
                
                if (showIndicator) {
                    ctx.fillStyle = "#FF9999";
                    ctx.font = "12px Arial";
                    ctx.fillText("âš¡ ì¸ë””ì¼€ì´í„° ì›€ì§ì„ ê°ì§€", 200, 180);
                }
            } else if (animationState === 'complete') {
                ctx.fillStyle = "#00FF00";
                ctx.fillText("âœ… ë¦¬íŠ¸ë¦¬ë¸Œ ì™„ë£Œ!", 350, 100);
                ctx.fillStyle = "#90EE90";
                ctx.font = "12px Arial";
                ctx.fillText("ë‹¤ì‹œ ì‹œì‘í•˜ë ¤ë©´ Replay ë²„íŠ¼ í´ë¦­", 300, 130);
            }
        }

        function drawIndicator(x, y) {
            // ì¸ë””ì¼€ì´í„° ë³¸ì²´
            ctx.fillStyle = "#FF3300";
            ctx.beginPath();
            ctx.arc(x, y, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // í•˜ì´ë¼ì´íŠ¸
            ctx.fillStyle = "#FF6644";
            ctx.beginPath();
            ctx.arc(x - 2, y - 2, 3, 0, Math.PI * 2);
            ctx.fill();
            
            // í…Œë‘ë¦¬
            ctx.strokeStyle = "#CC0000";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(x, y, 8, 0, Math.PI * 2);
            ctx.stroke();
            
            // ìˆ˜ë©´ íŒŒì¥ íš¨ê³¼
            if (animationState !== 'cast') {
                ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(x, y, 12, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(x, y, 16, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        draw();

        function resetAnimation() {
            animationState = 'cast';
            timer = 0;
            castProgress = 0;
            flyX = 100;
            flyY = WATER_LEVEL;
            indicatorX = 100;
            indicatorY = WATER_LEVEL;
            indicatorBobAmount = 0;
            isComplete = false; // ì™„ë£Œ í”Œë˜ê·¸ ë¦¬ì…‹
        }
    </script>
</body>
</html>
